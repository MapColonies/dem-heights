import { transform, mapKeys, mapValues, get } from 'lodash';
import { CswClient, IRequestExecutor, FilterField, SortField } from '@map-colonies/csw-client';
import { IPropPYCSWMapping, PycswDemCatalogRecord, RecordType, Link } from '@map-colonies/mc-model-types';
// import { Link } from '../AUTOGENERATED/GraphQLClass';
// import { CatalogRecordType, fieldTypes } from '../common/constants';
// import { SearchOptions } from '../graphql/inputTypes';
import { IService, requestExecutor } from './utils';

type CatalogRecordType = PycswDemCatalogRecord;
const fieldTypes = {
  isFootprint: (fieldName: string): boolean => fieldName === 'footprint',
  isLayerPolygonParts: (fieldName: string): boolean => fieldName === 'layerPolygonParts',
  isDate: (fieldName: string): boolean =>
    ['creationDate', 'ingestionDate', 'updateDate', 'sourceDateStart', 'sourceDateEnd', 'insertDate', 'validationDate'].includes(fieldName),
  isDiscrete: (fieldName: string): boolean => fieldName === 'discretes',
  isLinks: (fieldName: string): boolean => fieldName === 'links',
  isKeywords: (fieldName: string): boolean => fieldName === 'keywords',
  isSensor: (fieldName: string): boolean => ['sensorType', 'sensors'].includes(fieldName),
  isBoolean: (fieldName: string): boolean => ['hasTerrain'].includes(fieldName),
  isRegion: (fieldName: string): boolean => ['region'].includes(fieldName),
  isProductVersion: (fieldName: string): boolean => fieldName === 'productVersion',
  isNumber: (fieldName: string): boolean =>
    [
      'resolutionDegree',
      'resolutionMeter',
      'absoluteAccuracyLEP90',
      'relativeAccuracyLEP90',
      'heightRangeFrom',
      'heightRangeTo',
      'imagingSortieAccuracyCEP90',
    ].includes(fieldName),
};

export class SearchOptions {
  public filter?: FilterField[];
  public sort?: SortField[];
}

export class CswClientWrapper {
  private readonly typename: string;
  private readonly outputSchema: string;
  private readonly pyCSWKeys: IPropPYCSWMapping[];
  private readonly cswService: IService;
  private readonly defaultRequestHandler?: IRequestExecutor;

  public constructor(typename: string, pyCSWKeys: IPropPYCSWMapping[], outputSchema: string, cswService: IService, request?: IRequestExecutor) {
    this.typename = typename;
    this.outputSchema = outputSchema;
    this.pyCSWKeys = pyCSWKeys;
    this.cswService = cswService;
    this.defaultRequestHandler = request;
  }

  public async getRecords(start?: number, end?: number, opts?: SearchOptions): Promise<CatalogRecordType[]> {
    const cswClient = this.getCswClient();
    // eslint-disable-next-line
    let data = (await cswClient.GetRecords(this.outputSchema, start, end, opts))?.[this.typename];
    if (data === undefined) {
      return [];
    }
    data = Array.isArray(data) ? data : [data];
    const parsedData = this.transformRecordsToEntity(data as CatalogRecordType[]);
    return parsedData;
  }

  public async getRecordsById(idList: string[]): Promise<CatalogRecordType[]> {
    const cswClient = this.getCswClient();

    // eslint-disable-next-line
    let data = (await cswClient.GetRecordsById(this.outputSchema, idList))?.[this.typename];
    if (data === undefined) {
      return [];
    }
    data = Array.isArray(data) ? data : [data];
    const parsedData = this.transformRecordsToEntity(data as CatalogRecordType[]);
    return parsedData;
  }

  public async getDomain(domain: string): Promise<string[]> {
    const cswClient = this.getCswClient();

    // eslint-disable-next-line
    let domainResp = (await cswClient.GetDomain(domain))?.['csw:GetDomainResponse'];
    if (domainResp === undefined) {
      return [];
    }
    const valList = get(domainResp, 'domainValues[0].listOfValues.value') as Record<string, unknown>[];
    const parsedData = valList.map((val) => get(val, 'content[0]') as string);

    return parsedData;
  }

  public transformRecordsToEntity = (cswArray: CatalogRecordType[]): CatalogRecordType[] => {
    const { isDate, isDiscrete, isKeywords, isLayerPolygonParts, isLinks, isSensor, isRegion, isProductVersion, isBoolean, isFootprint, isNumber } =
      fieldTypes;

    const cswParsedArray = transform(
      cswArray,
      (result: Record<string, unknown>[], cswValue) => {
        const parsedKeys = mapKeys(cswValue, (value, key) => {
          const fixedKey = this.pyCSWKeys.find((cswMapping) => cswMapping.xmlElement === key)?.prop ?? key;
          return fixedKey;
        });
        const finalParsed = mapValues(parsedKeys, (val, key, obj) => {
          const recordType = get(obj, 'type') as RecordType;
          const SHOULD_SPECIAL_TREAT_FIELD = true;

          switch (SHOULD_SPECIAL_TREAT_FIELD) {
            case isFootprint(key): {
              // eslint-disable-next-line
              return JSON.parse(val as string);
            }
            case isLayerPolygonParts(key): {
              switch (recordType) {
                case RecordType.RECORD_RASTER:
                case RecordType.RECORD_DEM:
                  // eslint-disable-next-line
                  return JSON.parse(val as string);
                default:
                  return {};
              }
            }
            case isDiscrete(key): {
              switch (recordType) {
                case RecordType.RECORD_RASTER:
                  // eslint-disable-next-line
                  return JSON.parse(val as string);
                default:
                  return undefined;
              }
            }
            case isLinks(key): {
              const linksArr = Array.isArray(val) ? val : [val];
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              const processedLinks = linksArr.map((item: any): Link => {
                return {
                  protocol: get(item, '$.scheme') as string,
                  name: get(item, '$.name') as string,
                  description: get(item, '$.description') as string,
                  url: get(item, '_') as string,
                };
              });
              return processedLinks;
            }
            case isDate(key):
              return new Date(val as string);
            case isKeywords(key):
              return val?.toString(); //might be an Array
            case isSensor(key):
              return val !== undefined ? (val as string).split(',') : [];
            case isRegion(key):
              return val !== undefined ? (val as string).split(',') : [];
            case isProductVersion(key):
              switch (recordType) {
                case RecordType.RECORD_3D:
                  return val?.toString();
                default:
                  return val;
              }
            case isBoolean(key): {
              // Python booleans notations are capitalized, we should parse it to JS notation.
              if (typeof val === 'string') {
                const isBooleanValue = ['True', 'False'].includes(val);
                // eslint-disable-next-line @typescript-eslint/naming-convention
                const pythonBooleanStringMap: Record<string, boolean> = { True: true, False: false };

                if (isBooleanValue) {
                  return pythonBooleanStringMap[val];
                }
              }

              return val;
            }
            case isNumber(key):
              // eslint-disable-next-line
              console.log('NUMBER FIELD:', key, '---', val, '---', JSON.parse(val as string))
              // eslint-disable-next-line
              return JSON.parse(val as string);
            default:
              return val;
          }
        });
        result.push(finalParsed);
      },
      []
    );
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //@ts-ignore
    return cswParsedArray;
  };

  private getCswClient(): CswClient {
    const cswRequestHandlerFallback = async (url: string, method: string, params: Record<string, unknown>): Promise<unknown> =>
      requestExecutor(this.cswService, method, params);

    const cswClient = new CswClient('NOT_IN_USE.COM', this.defaultRequestHandler ?? cswRequestHandlerFallback);

    return cswClient;
  }
}
